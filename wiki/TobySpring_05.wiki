#summary 토비의 스프링, 1부 이해 - 5장 서비스 추상화

<wiki:toc max_depth="2" />

= 정리 =

지금까지 만든 DAO 에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴볼 것이다.

== 5.1 사용자 레벨 관리 기능 추가 ==

CRUD 의 기초적인 작업만 있었던 UserDao 를 통해 사용자의 레벨을 조정해주는 기능을 만들도록 한다.

*Level이늄*

DB 에 사용자레벨 필드를 추가하고 User에 도 사용자레벨 프로퍼티를 추가한다. 이때 프로퍼티를 숫자로 지정할 경우 의미없는 숫자가 사용될 가능성도 있기 때문에 자바 5 이상에서 제공하는 이늄(enum)을 이용해보도록 한다.

{{{
public enum Level {
   BASIC(1), SILVER(2), GOLD(3); // 세개의 이늄 오브젝트 정의
   private final int value;
   Level(int value) { // DB에 저장할 값을 넣어줄 생성자를 만들어준다
      this.value = value;
   }

   public int initValue() {
      return value;
   }

   public static Level valueOf(int value) {
      switch(value) {
         case 1 : return BASIC;
         case 2 : return SILVER;
         case 3 : return GOLD;
         default : throw new AssertionError("Unknown value : "+value); 
      }
   }
}
}}}

User, UserDaoTest, UserDaoJdbc, RowMapper 등을 모두 수정하고 사용자를 수정하는 update 메소드를 추가한다.

*UserService.upgrateLevels()*

사용자 관리 로직은 어디에 두어야 좋을까? DAO 는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이니 적당하지 않다. 사용자 관리 비즈니스 로직을 담을 Service 클래스를 하나 추가하도록 한다.

UserService 는 인터페이스 타입으로 UserDao 를 DI 받아 사용하도록 한다. 그러기 위해서는 UserService 도 스프링의 빈으로 등록 되어야 한다. UserService 를 위한 테스트 클래스도 추가한다.

*upgradeLevels() 메소드*

{{{
public void upgradeLevels() {
   List< User > users = userDao.getAll(); // 사용자 정보를 모두 가져옴
   for(User user : users) {
      Boolean changed = null;
      // 각 레벨에 맞는 조건을 검사하고 changed 변수에 변경여부를 담는다.
      if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
         user.setLevel(Level.SILVER);
         changed = true;
      } else if(user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
         user.setLevel(Level.GOLD);
         changed = true;
      } else if(user.getLevel() == Level.GOLD) { changed = false; }
      } else changed = false;
      if(changed) userDao.update(user); // 변경이 있는 User 만 업데이트 한다
   }
}
}}}

{{{
@Test
public void upgradeLevels() {
   userDao.deleteAll();
   for(User user : user) userDao.add(user);
   userService.upgradeLevels();
   // 예상 레벨을 검증
   checkLevel(users.get(0), Level.BASIC);
   checkLevel(users.get(1), Level.SILVER);
   checkLevel(users.get(2), Level.SILVER);
   checkLevel(users.get(3), Level.GOLD);
   checkLevel(users.get(4), Level.GOLD);
}

private void checkLevel(User user, Level expectedLevel) { // 중복되는 코드를 헬퍼 메소드로 분리
   User userUpdate = userDao.get(user.getId());
   assertThat(userUpdate.getLevel(), is(expectedLevel));
}
}}}

*UserService.add()*

사용자 레벨 변경 기능은 완료하였지만 사용자가 처음 등록 되었을 때 기본적으로 BASIC 레벨을 가져야 하는 코드를 추가하도록 한다. 이 로직은 DAO 나 User 클래스에 책임을 주기에는 적절하지 못하므로 UserService 에 넣어보도록 한다. add() 를 호출 할 때 Level 이 비어있으면 BASIC 을 넣어주도록 하는 것이다.

{{{
public void add(User user) {
   if (user.getLevel() == null) user.setLevel(Level.BASIC);
   userDao.add(user);
}
}}}

{{{
@Test
public void add() {
   userDao.deleteAll();
   User userWithLevel = users.get(4);
   User userWithoutLevel = users.get(0);
   userWithoutLevel.setLevel(null);
   
   userService.add(userWithLevel);
   userService.add(userWithoutLevel);
  
   User userWithLevelRead = userDao.get(userWithLevel.getId());
   User userWithoutLevelRead = userDao.get(userWithoutLevel.getId());

   assertThat(userWithLevelRead.getLevel(), is(userWithLevel.getLevel()));
   assertThat(userWithoutLevelRead.getLevel(), is(userWithoutLevel.getLevel()));
}
}}}

*코드 개선*

 * 코드에 중복된 부분은 없는가?
 * 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
 * 코드가 자신이 있어야 할 자리에 있는가?
 * 변경이 일어난다면 어떤것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

upgradeLevels() 는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여 있으므로 이를 리팩토링 한다. 일단 작업의 기본 흐름만 만든 후 구체적인 메소드를 만들어보도록 한다.

{{{
public void upgradeLevels() {
   List< User > users = userdao.getall();
   for(User user : users) {
      if(canUpgradeLevel(user)) {
         upgradeLevel(user);
      }
   } 
}

private boolean canUpgradeLevel(User user) {
   Level currentLevel = user.getLevel();
   switch(currentLevel) {
      case BASIC : return (user.getLogin() >= 50);
      case SILVER : return (user.getRecommend() >= 30);
      case GOLD : return false;
      default throw new IllegalArgumentException("Unknown Level : "+currentLevel);
   }
}

private void upgradeLevel(User user) {
   if(user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
   else if(user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
   userDao.update(user);
}
}}}

이때 upgradeLevel() 메소드를 Level enum 에서 다음 단계 레벨정보를 담을 수 있도록 수정해서 변경해보도록 한다.

{{{
public enum Level {
   GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);

   private final int value;
   private final Level next;

   Level(int value, Level next) {
      this.value = value;
      this.next = next;
   }

}
}}}

{{{
public void upgradeLevel() { // User 클래스에 추가
   Level nextLevel = this.level.nextLevel();
   if(nextLevel == null) {
      throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다");
   } else {
      this.level = nextLevel;
   }
}
}}}

{{{
private void upgradeLevel(User user) {
   user.upgradeLevel();
   userDao.update(user);
}
}}}

이렇게 개선된 코드들은 각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉬우며 변경이 필요할 떄 어디를 수정해야 할지도 쉽게알 수 있게 되었다.

{{{
@Test
public void upgradeLevels() {
   userDao.deleteAll();
   for(User user : users) userDao.add(user);
   
   userService.upgradeLevels();
 
   checkLevelUpgraded(users.get(0), false);
   checkLevelUpgraded(users.get(1), true);
   checkLevelUpgraded(users.get(2), false);
   checkLevelUpgraded(users.get(3), true);
   checkLevelUpgraded(users.get(4), false);
}

private void checkLevelUpgraded(User user, boolean upgraded) {
   User userUpdate = userDao.get(user.getId());
   if(upgraded) {
      assertThat(userUpdate.getLevel(), is(user.getLevel().nextLevel()));
   } else {
      assertThan(userUpdate.getLevel(), is(user.getLevel());
   }
}
}}}

업그레이드 조건인 로그인 횟수와 추천횟수가 각 코드에서 중복되오 있으므로 이를 상수로 빼내도록 한다.

{{{
public static final int MIN_LOGCOUNT_FOR_SILVER = 50;
public static final int MIN_RECOMMEND_FOR_GOLD = 30;

...
      case BASIC : return (user.getLogin() >= MIN_LOGCOUNT_FOR_SILVER);
      case SILVER : return (user.getRecommend() >= MIN_RECOMMEND_FOR_GOLD);
...
}}}

업그레이드 정책이 변경될 경우를 위해 UserLevelUpgradePolicy 인터페이스를 만들고 UserService 에서 이를 구현한 클래스를 DI 받아서 사용할 수 있다.

{{{
public interface UserLevelUpgradePolicy {
   boolean canUpgradeLevel(User user);
   void upgradeLevel(User user);
}
}}}

== 5.2 트랜잭션 서비스 추상화 ==

== 5.3 서비스 추상화와 단일 책임 원칙 ==
== 5.4 메일 서비스 추상화 ==

= 생각하기 =