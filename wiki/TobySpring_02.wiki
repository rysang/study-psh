#summary 토비의 스프링, 1부 이해 - 2장 테스트

<wiki:toc max_depth="2" />

= 정리 =

개요..

== 2.1 UserDaoTest 다시보기 ==

테스트란 개발자가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

*웹을 통한 DAO 테스트 방법의 문제점*

우리는 보통 DAO 를 테스트 할 때, 서비스계층, MVC 프레젠테이션 계층까지 포함한 모든 기능을 대충이라도 만든 후 웹 화면을 띄어서 확인했다. 하지만 이 방법은 DAO 에 대한 테스트로서 단점을 너무나 많이 가지고 있다.

모든 기능을 다 만들고 나서야 테스트가 가능하며, 어디에서 문제가 발생했는지를 찾아내는 수고를 더해야 한다. 

*작은 단위의 테스트*

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트 하는 것이 바람직하다. UserDaoTest 를 수행해서 테스트 할 때에는 웹 화면등의 다른 작업이 필요하지 않았다. 에러가 나더라도 범위가 작아서 찾기가 수월했다. 이렇게 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 1장에서 나왔던 관심사의 분리가 여기에도 적용되는 셈이다.

이렇게 작은 단위의 코드에 대해 테스트를 수행하는 것을 단위 테스트라고 한다. 작게 보자면 메소드를 하나의 단위라고 생각할 수도 있고, 사용자 기능을 통 틀어서 하나의 단위라고 생각할 수 있다.

*자동수행 테스트 코드*

UserDaoTest 의 특징 중 하나는, 테스트할 데이터가 코드를 통해 제공되어 자동으로 실행한다는 점이다. 웹을 통한 테스트 시에는 테스트 데이터를 일일이 입력해줘야 하는 번거로움이 있었다. 그 번거로움이 없어졌기 때문에 테스트를 빠르게 실행할 수 있다. 그래서 자주 반복할 수 있는 장점이 생겼다.

처음에는 UserDao 안에 main 메소드를 사용해서 테스트 코드를 만들어 줬지만 UserDaoTest 라는 별개의 클래스를 만들어서 그 안에 테스트 코드를 넣도록 해서 확실히 분리하도록 하였다.

*지속적인 개선과 점진적인 개발을 위한 테스트*

UserDao 를 만들면서 UserDaoTest 를 통한 테스트는 개발에 대한 확신을 갖게 하였고, 새로운 기능을 추가하려 할 때도 미리 만들어 둔 테스트 코드는 유용하게 쓰였다. 

*UserDaoTest 의 문제점*

UserDaoTest 가 번거로운 수동 테스트에 비해 장점이 많은 것은 사실이지만 단점도 가지고 있다. 첫번째로 수동확인작업이 필요하다는 점이다. 결과 값을 출력해서 직접 확인해야만 했다. 검증해야하는 양이 많아질 수록 불편함을 느낄 수 있는 문제다.

두번째로 실행작업의 번거로움이다. main 메소드라 하더라도 그것을 매번 실행하여야 하는 점은 DAO 가 많아 질 수록 그만큼 힘들어 질 것이다. 그래서 main 메소드를 이용하는 방법보다 좀 더 편리하고 체계적인 테스트를 실행하고 확인할 수 있도록 한다.


== 2.2 UserDaoTest 개선 ==

*테스트 검증의 자동화*

add 메소드로 사용자를 등록하고 get 메소드를 통해 서로 일치하는지 확인하는 테스트 코드를 개선해보겠다. 기존의 코드에서는 값을 출력해서 직접 확인하였지만, 결과의 경우를 '테스트성공', '테스트실패' 로 두고 변경해보겠다.

{{{
if(!user.getName().equals(user2.getName())) {
   System.our.println("테스트 실패 (name)");
} else if(!user.getPassword().equals(user2.getPassword())) {
   System.our.println("테스트 실패 (password)");
} else {
   System.our.println("테스트 성공");
}
}}}

*JUnit 테스트로 전환*

main 메소드로 만든 테스트는 테스트로서 필요한 기능은 모두 갖추었지만, main 메소드로는 한계가 있다. 그렇기 때문에 자바 테스팅 프레임워크가 불리는 JUnit 을 사용해보도록 한다.

새로 만들 테스트는 JUnit 프레임웍이 요구하는 두 가지 조건을 따라야 한다. 첫번째는 메소드가 public 으로 선언되어야 하고, 다른 하나는 @Test 라는 애노테이션이 붙어야 한다는 것이다.

{{{
import org.juni.Test;
...
public class UserDaoTest {
   @Test // 테스트용 메소드임을 알려주는 애노테이션
   public void addAndGet() throws SQLException { // public 으로 선언
      ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
      UserDao dao = context.getBean("userDao", UserDao.class");
      ...
      assertThat(user2.getName(), is(user.getName()));
      assertThat(user2.getPassword(), is(user.getPassword()));  
   }
}
}}}

그리고 if/else 문 대신에 JUnit이 제공해주는 assertThat 이라는 스태틱 메소드를 이용해서 변경한다.

이 테스트를 실행하기 위해 main 메소드를 추가하고 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어준다.

{{
import org.junit.runner.JUnitCore;
...
public static void main(String[] args) {
   JUnitCore.main("springbook...UserDaoTest");
}
}}

JUnit은 assertThat 을 이용해 검증을 했을 때 기대한 결과가 아닐 경우 AssertionError 를 던지므로, 테스트가 실패했음을 알 수 있다.

== 2.3 개발자를 위한 테스팅 프레임워크 JUnit ==

자바의 표준 테스팅 프레임웍이라 불리우는 JUnit 프레임웍에 대해 더 자세히 알아보도록 한다. IDE 를 통한 JUnit 테스트는 main 메소드가 필요없이 특정 메뉴를 통해 자동으로 실행된다. 한번에 여러 메소드 뿐만 아니라 여러 클래스에 대한 테스트도 동시에 실행할 수 있으며, 개발자 개인별로 테스트 할 때는 매우 유용하다.

이클립스 JUnit 단축키 : alt + shift + x + t, 한번 실행후에는 f11

*테스트 결과의 일관성*

UserDaoTest를 사용하기 전에 USER 테이블의 모든 정보를 삭제해줘야 하는 번거로움이 있었다. 깜박하고 삭제하지 않았을 경우에는 테스트시가 의도하지 않게 실패할 것이다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 하는 일관성을 가져야 한다. 그러므로 우리는 deleteAll, getCount 라는 메소드를 추가하여 일관성을 보장할 수 있는 테스트로 개선해보도록 한다.

{{{
@Test
public void addAndGet() throws SQLException {
   ...
   dao.deleteAll();
   assertThat(dao.getCount(), is(0)); // getCount 메소드는 deleteAll 에 대한 검증도 할 수 있다.
   ...
   dao.add(user);
   assertThat(dao.getCount(), is(1));
   ...
}
}}}

*예외조건에 대한 테스트*

get 메소드로 전달된 id 값에 해당하는 사용자 정보를 가져올 때 데이터가 없을 경우가 발생 할 수 있다. 그래서 데이터가 없을 경우 EmptyResultDataAccessException 예외를 던지도록 해본다. 이 경우 해당 예외가 던져졌을 때를 테스트 성공이라고 판단하도록 한다.

{{{
@Test(expected=EmptyResultDataAccessException.class) // expected 엘리먼트 추가
public void getuserFailure() throws SQLException {
   ...
   UserDao dao = context.getBean("userDao", UserDao.class);
   dao.deleteAll();
   assertThat(dao.getCount(), is(0));
   dao.get("unknown_id"); // 이 때 예외가 발생해야 한다.
}
}}}

위 테스트가 성공하려면 UserDao 의 get 메소드에도 약간의 수정이 필요하다.

{{{
public User get(String id) throws SQLException {
   ...
   ResultSet rs = ps.executeQuery();
   User user = null; // null 로 초기화
   if(rs.next()) {
      user = new User();
      user.setId(rs.getString("id"));
      ...
   }
   ...
   if(user==null) throw new EmptyResultDataAccessException(1); // 예외를 던져준다
   return user;
}
}}}

*포괄적인 테스트*

개발자가 테스트를 직접 만들 때 자주하는 실수가 하나 있다. 성공하는 테스트만 골라서 만드는 것이다. 스프링의 창시자인 로드존슨은 "항상 네거티브 테스트를 먼저 만들라" 라는 조언을 했다. 이렇게 부정적인 케이스를 먼저 만드는 습관을 들이는 것이 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능할 것이다.

*테스트 주도 개발 (TDD)*

get 메소드에 대한 예외 테스트를 만들 때 우리는 테스트를 먼저 작성하고, UserDao 의 get 메소드를 수정하는 순서로 진행하였다. 테스트를 통해 추가하고자 하는 기능을 코드로 표현하면서, 실제 기능을 가진 코드를 만들고 나면 테스트가 성공한 순간에 개발도 같이 작업완료가 될 것이다.

이런 순서를 따라서, 검증해 줄 수 있는 테스트를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법을 TDD 라고 한다. "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 TDD 의 기본 원칙이다. TDD 에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가도록 권장한다. 

*테스트 코드 개선*

UserDaoTest 에는 context 생성과, userDao 를 가져오는 부분이 반복되어 나타나고 있다. 이를 JUnit 이 제공하는 기능으로 리팩토링 해본다.

{{{
import org.junit.Before;
...
public class UserDaoTest {
   private UserDao dao; // setUp 에서 만드는 오브젝트를 테스트 메소드에서 사용할 수 있도록 인스턴스 변수로 선언
   @Before // @Test 메소드가 실행되기 전에 먼저 실행되는 메소드
   public void setUp() {
      ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
      this.dao = context.getBean("userDao", UserDao.class);
   }
   ...
}
}}}

@Before 라는 애노테이션을 이용해서 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능을 사용했다.

JUnit 이 하나의 테스트 클래스를 가져와서 테스트를 수행하는 방식은 다음과 같다.

 # 테스트 클래스에서 @Test 가 붙은 public 이고 void 형이며 파라미터가 없는 테스트 메소드를 모두 찾는다. 
 # 테스트 클래스의 오브젝트를 하나 만든다.
 # @Before 가 붙은 메소드가 있으면 실행한다.
 # @Test 가 붙은 메소드를 하나 호출하고, 결과를 저장해둔다.
 # @After 가 붙은 메소드가 있으면 실행한다.
 # 나머지 테스트 메소드에 대한 2~5번을 반복한다.
 # 모든 테스트의 결과를 종합해서 돌려준다.

여기서 기억해야 할 사항은 각 테스트 메소드를 실행할 때 마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다. 한 번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 이는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위한 것이다. 덕분에 인스턴스 변수도 부담없이 사용할 수 있게 되었다.

지금은 모든 메소드에서 공통된 코드를 가졌기 대문에 @Before 를 사용했지만 일부만 공통된 코드를 가졌을 때는 일반 메소드 추출 방식을 써야 할 것이다.

*픽스처(fixture)*

테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처 라고 한다. 일반적으로 픽스처는 @Before 에서 생성하는 것이 편리하다. UserDaoTest 에서는 dao 나 get 메소드의 각 user 객체들이 픽스처라고 볼 수 있다. 

{{{
public class UserDaoTest {
   private User dao;
   private User user1, user2, user3;
   
   @Before
   public void setUp() {
      ...
      this.user1 = new User(...);
      this.user2 = new User(...);
      this.user3 = new User(...);
      ...
   }
}
}}}

== 2.4 스프링 테스트 적용 ==

applicationContext 생성 부분이 @Before 에 들어가면서 메소드 갯수만큼 만들어지게 된다. applicationContext 가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화 하면서 시간이 소요되고, 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 하는 문제점이 있을 수 있다. 

applicationContext 의 경우 상태를 갖지 않아 상태가 바뀌진 않는다. 그래서 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다. 이럴 때는 JUnit 테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 사용하도록 한다.

{{{
@RunWith(SpringJUnit4ClassRunner.class) // JUnit 확장기능 지정, 생성과 관리 작업을 진행
@ContextConfiguration(locations="/applicationContext.xml") // 설정파일의 위치를 지정
public class UserDaoTest {
   @Autowired
   private ApplicationContext context;
   ...
   @Before
   public void setUp() {
      this.user1 = new User(...);
      ...
   }
}
}}}

각 메소드에서 사용되는 context 를 출력함으로써 한번만 생성된다는 것을 확인할 수 있다.

여러개의 테스트 클래스가 있더라도 모두 같은 설정파일을 이용한다면 applicationContext 를 공유하게 해준다.

@Autowired 는 DI 에서 사용되는 애노테이션으로 변수타입과 일치하는 컨텍스트 내의 빈을 찾는다. 이 경우 생성자 또는 수정자 메소드가 없어서 주입이 가능하며 별도의 DI 없이 빈을 자동으로 가져온다. 이를 자동와이어링이라고 한다. 이를 사용하게 되면 UserDao 도 자동와이어링 할 수 있으며 DL 할 때보다 더 단순한 코드를 사용할 수 있다. 단 값은 타입이 2개 이상 있을 경우는 변수의 이름과 같은 빈을 가져오며 이마저도 없을 경우 예외가 발생하게 된다.

*DI와 테스트*

UserDao 와 DB 커넥션 생성 클래스 사이에는 DataSource 라는 인터페이스를 뒀다. 이렇게 인터페이스를 두고 DI 를 적용해야 하는 이유는 다음과 같다.

 # 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
 # 다른 차원의 서비스 기능을 도입할 수 있다.
 # DI 는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다.

개발용 DB 접속 정보가 달라서 DataSource 의 정보가 변경된다고 생각했을 때 테스트 코드에 의한 DI 를 이용해서 DataSource 에 대한 정보를 직접 바꿔줄 수 있다.

{{{
...
@DirtiesContext // applicationContext 의 구성이나 상태가 변경한다는 것을 알려준다.
public class UserDaoTest {
   @Autowired
   UserDao dao;
   @Before
   public void setUp() {
      ...
      DataSource dataSource = new SingleconnectionDataSource(...);
      dao.setDataSource(dataSource); // 코드에 의한 수동 DI
      ... 
   }  
}
}}}

위 코드처럼 XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다. 그러기 위해선 applicationContext의 상태가 변경된다는 것을 알려주는 @DirtiesContext 애노테이션을 추가해서 변경한 컨텍스트가 다음 테스트에 영향을 주지 않게 한다. 이는 클래스 레벨이 아닌 메소드 레벨에도 추가할 수 있다.

하지만 이 때문에 applicationContext 를 매번 만드는 것 보단 테스트 전용 설정파일을 두는 방법이 더 효율적일 것이다. 설정파일을 하나 더 만들고 설정파일 경로만 바꿔주도록 한다.

{{{
...
@ContextConfiguration(locations="/test-applicationContext.xml")
...
}}}

이 외에도 스프링 컨테이너를 사용하지 않는 테스트를 만들 수 있다. 이는 applicationContext 를 사용하지 않으니 테스트 시간도 절약되며, 코드는 더 단순해지고 이해하기 편해질 것이다.

DI를 테스트에 이용하는 세가지 방법을 알아보았다. 이는 모두 장단점을 가지고 있다.

우선적으로 고려해야할 방법은 스프링 컨테이너 없이 테스트 하는 것이다. 이는 속도도 가장 빠르고 간결해진다.

여러 오브젝트와 복잡한 의존관계를 가지고 있는 오브젝트를 테스트해야 한다면 스프링의 설정을 이용한 DI 방식의 테스트를 이용한다.

예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우는 @DirtiesContext 애노테이션을 이용하도록 한다.

*침투적 기술과 비침투적 기술*

침투적 기술은 기술을 적용했을때 코드에 API 가 등장하거나 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 말한다. 이는 코드가 해당 기술에 종속되는 결과를 가져온다.

비침투적 기술은 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 한다. 스프링은 이런 기술의 대표적인 예이다. 그래서 스프링 컨테이너 없는 DI 테스트도 가능한 것이다.


== 2.5 학습 테스트로 배우는 스프링 ==

때로는 자신이 만들지 않은 프레임웍이나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 하는데 이를 학습 테스트라고 한다. 검증이 목적이 아닌 사용법을 익히는 것이라고 볼 수 있다.

학습 테스트의 장점은 다음과 같다.

 # 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다. 
 # 학습 테스트 코드를 개발 중에 참고 할 수 있다는 점이다. 
 # 프레임웍이나 제품의 업그레이드시 호환성 검증을 돕는다.
 # 테스트 작성에 대한 훈련이 된다.
 # 새로운 기술을 공부하는 과정이 된다.

위에서 테스트 컨텍스트가 매번 주입해주는 applicationContext 는 항상 같은 오브젝트이라고 했는데 이를 확인할 테스트를 작성해 볼 수도 있다.

*버그 테스트*

코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다. 버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 실패하는 코드를 만들고 테스트가 성공할 수 있도록 코드 수정을 한다.

버그 테스트의 장점은 다음과 같다.
 
 # 테스트의 완성도를 높여준다. 이후 비슷한 문제가 나오더라도 이를 통해 쉽게 추적이 가능하다.
 # 버그의 내용을 명확하게 분석하게 해준다. 
 # 기술적인 문제를 해결하는 데 도움이 된다.

*동등분할* : 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트 하는 방법

*경계값 분석* : 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트 하는 방법. 숫자의 입력값인 경우 0 이나 그 주변 값, 정수의 최대값, 최소값 등으로 테스트.

= 생각하기 =

돌이켜보면 개발을 하면서 테스트가 없었던 경우는 단 한번도 없었다. 고작 UI 가 바뀌는 코드이더라도 말이다. 새로운 기능을 적용할 때에는 테스트가 먼저인 경우도 더러 있었다. 내가 원하는 대로 제대로 작동하는지 확인이 필요했으니깐. 하지만 이렇게 늘 필요로 했던 과정에 대해 단순하게 생각해왔던 것에 비해 테스트는 어떻게 보면 많은 단계를 거쳐 이뤄졌던 것 같다. 토비님의 글 처럼 모든 기능이 대충이라도 작성된 다음에야만 테스트가 가능하다 라는 관점에서 볼때 말이다.

현재 프로젝트 소스안에도 JUnit 테스트를 위한 클래스들이 몇개 존재하지만 소수의 개발자들만 이용해왔다. 실제로 나도 정규화 등 몇번 사용안해봤지만 한 번은 테스트를 위한 방대한 양의 정보가 필요한 경우가 있어서 '에잇 차라리 UI 통해서 클릭해보지 뭐! 몇번이나 해보겠어?' 라며 테스트 클래스를 외면한 경우도 있다. 더 솔직히 말하자면 테스트에 관한 문법도 제대로 몰랐고 큰 관심도 없었다. (이제 와서 생각해보면 applicationContext 로 dao 가져와서 select 한 후 테스트 할 것을... 이 엄청난 데이터를 언제 일일이 다 입력해! 라고 생각했었다. 다른 테스트 작성된 것을 쭉- 훓어 보고는 DB 에서 값을 못 가져오는 건가? 하면서 ㅋㅋ)

JUniCore가 메인메소드를 실행해주는 부분에서는 JUnit 이 얼마나 우리를 편하게 해주고 있는지 느낄 수 있었다. 그리고 JUnit 이 테스트 클래스를 가져와 수행하는 방식에 대해 설명하는 부분에서는 개발하면서 그냥 지나칠 수 있었던 부분들, 솔직히 잘 신경쓰지 않는 부분들, 예를 들면 테스트마다 새로운 객체를 만든다던지 하는 것에 대해 자세히 알 수 있어서 좋았다. 역시 책을 통해서 공부를 하게 되면 이런 점이 좋은 것 같다.

교육때는 assertEquals 나 assertTrue 를 주로 사용했으나 책에서는 assertThat 을 먼저 소개하고 있었다. 그 외에도 수많은 메소드가 있겠지만 assertThat 은 is 가 나오니 약간 영어를 읽는 기분? 이었다. 실제로 나는 실습하면서 그냥 assertEquals 나 assertTrue 를 이용해서 실습했다. 안영회님(?)블로그에서 "내 생각엔 assertThat 자체는 영어문화권이 아닌 우리에게 큰 의미는 없다." 이란 글을 보니 안심이 되... 는건 왜? ㅋㅋㅋ


책보단 교육을 통해서 먼저 느낀 것이지만 테스트에 대한 개념을 이렇게 이론화(?) 한 후에 생각해 본 것은 느낌이 좀 다르다. 이렇게 교육이나 책을 통해서 알려주니 '아~ 정말 정말 중요하고 효과적인 건가보다!' 라는.. 심리적인 효과도 솔직히 조금 있었다 -_-; 하하하 내가 지금 이렇게 느낀 만큼 얼마나 테스트를 실전에서 적용해볼런지는 몰라도 이제는 방법과 그 효과를 알았으니 조금씩이라도 적용해 보도록 노력할 것이다.