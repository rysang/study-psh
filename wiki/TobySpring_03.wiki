#summary 토비의 스프링 1부, 제3장 템플릿

<wiki:toc max_depth="2" />

= 내용정리 =

템플릿이란, 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독릭시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

== 3.1 다시 보는 초난감 DAO ==

UserDAO 에는 아직 예외처리에 대한 문제점이 남아 있다. JDBC 코드라면 반드시 지켜야 할 리소스 반환 문제다.

그래서 우리는 try/catch/finally 구문을 사용해서 수정해보도록 한다.

{{{
public void deleteAll() throws SQLException {
   Connection c = null;
   PreparedStatement ps = null;

   try {
      c = dataSource.getConnection();
      ps = c.preareStatement("delete from users");
      ps.executeUpdate();
   } catch (SQLException e) {
      throw e;
   } finally {
      if(ps != null) {
         try { ps.close(); } catch (SQLException e) { }
      }
      if(c != null) {
         try { c.close(); } catch (SQLException e) { }
      }
   }
}
}}}

조회의 경우 ResultSet 도 마찬가지로 리소스를 반환하도록 한다.


== 3.2 변하는 것과 변하지 않는 것 ==

try/catch/finally 를 사용하고 나서 발견되는 문제점은 모든 메소드마다 해당 구문이 반복된다는 것이다.
그래서 변하는 부분을 메소드로 추출해 본다.

{{{
public void deleteAll() throws SQLException {
   ...
   try {
      c = dataSource.getConnection();
      ps = makeStatement(c);
      ps.executeUpdate();
   } catch (SQLException e) {
      ...
   } finally {
      ...
   }
}

private PreparedStatement makeStatement(Connection c) throws SQLException {
   PreparedStatement ps;
   ps = c.prepareStatement("delete from users");
   return ps;
}
}}}

하지만 이 경우 분리시킨 메소드를 다른 곳에서 재사용할수가 없다. 뭔가 거꾸로 된 듯한 느낌이다.

*템플릿 메소드 패턴의 적용*

템플릿 메소드 패턴을 적용해서 분리해보도록 한다. UserDAO의 makeStatement 메소드를 추상메소드로 두고, 각 기능을 담당하는 메소드를 서브 클래스에 적용해본다.

{{{
abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;
}}}

{{{
public class UserDaoDeleteAll extends UserDAO {
   protected PreparedStatement makeStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("delete from users");
      return ps;
   }
}
}}}

하지만 이 방법은 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 하는 단점이 생겼다. 또한 확장구조가 이미 클래스를 설계하는 시점에서 고정되어서 유연성이 떨어진다는 점이다.

*전략 패턴(Strategy Pattern)의 적용*

템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이 Context(맥락)와 Strategy(전략)으로 분리해서 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략패턴이다.

deleteAll 메소드에서 변하지 않는 부분을 contextMethod 로 두고, PrepaaredStatement 를 만들어 주는 외부 기능이 Strategy 부분이 되는 것이다.
 
{{{
...
public interface StatementStrategy {
   PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
}}}

{{{
...
public class DeleteAllStatement implements StatementStrategy {
   public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("delete from users");
      return ps;
   }
}
}}}

{{{
public void deleteAll() throws SQLException {
   ...
   try {
      c = dataSource.getConnection();
      StatementStrategy strategy = new DeleteAllStatement();
      ps = strategy.makePreparedStatement(c);
      ps.executeUpdate();
   } catch {
      ...
   } finally {
      ...
   }
}
}}}

전략패턴을 이용해서 컨텍스트는 그대로 유지되면서 전략을 바꿔쓸 수 있게 되었다. 하지만 컨텍스트 안에서 이미 구체적인 DeleteAllStatement 클래스를 사용하도록 고정되어 있다. 

*DI 적용을 위한 클라이언트/컨텍스트 분리*

전략패턴에서 컨텍스트가 어떤 전략을 따를지 결정하는 것은 클라이언트가 결정해야 한다. 그래서 클라이언트를 두려고 보니 1장에서 사용했던 오브젝트 팩토리 사용과 비슷하게 되었다.

컨텍스트에 해당하는 부분은 별도의 메소드로 독립시키고 deleteAll 메소드를 클라이언트로 사용하도록 한다. 이때 전략 인터페이스인 StatementStrategy 는 메소드의 파라미터로 지정될 것이다.

{{{
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
   Connection c = null;
   PreparedStatement ps = null;
   try {
      c = dateSource.getConnection();
      ps = stmt.makePreparedStatement(c); // 전략 파라미터 사용
      ps.executeUpdate();
   } cateh (SQLException e) {
      ...
   } finally { 
      ...
   }
}
}}}

{{{
public void deleteall() throws SQLException {
   StatementStrategy st = new DeleteAllStatement(); // 클라이언트가 전략 생성
   jdbcContextWithStatementStrategy(st); // 호출
}
}}}

전략패턴의 구조를 제대로 갖춘 이 소스는 비록 클라이언트와 컨텍스트를 클래스로 분리하지는 않았지만 의존관계와 책음으로 볼 때 DI 구조라고 이해할 수도 있다. 두개의 오브젝트가 하나의 클래스 안에 담긴 이런 경우에는 DI가 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 한다. 이를 코드에 의한 DI라는 의미로 수동DI 라고 부를 수도 있다.


== 3.3 JDBC 전략 패턴의 최적화 ==

이번엔 add 메소드도 전략패턴을 이용해서 개선해본다.

{{{
public class AddStatement implements StatementStrategy {
   User user;

   public AddStatement(User user) {
      this.user = user;
   }

   public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values (?, ?, ?)");
      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());
      return ps;
   }
}
}}}

{{{
public void add(User user) throws SQLException {
   StatementStrategy st = new AddStatement(user);
   jdbcContextWithStatementStrategy(st);
}
}}}

이 때 user 객체는 생성자를 통해 제공받도록 한다. 앞으로 비슷한 기능의 DAO 메소드가 필요할 때 마다 Strategy 전략과 jdbcContextWithStatmentStrategy 컨텍스트를 활용할 수 있게 되었다.

*전략과 클라이언트의 동거*

이렇게 개선을 했는 데도 아직 문제가 남아 있다. DAO 메소드 마다 새로운 StatementStrategy 구현 클래스를 생성해야 하는 것과 DAO 메소드에서 전달해야 할 User 같은 부가적인 정보가 있는 것이다.

AddStatementStrategy 가 쓰이는 곳은 add 메소드 한군데 이므로 클래스 파일이 많아 지는 것을 해결할 수 있도록 로컬 클래스를 사용해보도록 한다.

{{{
public void add(final User user) throws SQLException { // 로컬변수에 직접 접근할 수 있도록 final 로 선언
   class AddStatement implements StatementStrategy {
      public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
         PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values (?, ?, ?)");
         ps.setString(1, user.getId());
         ps.setString(2, user.getName());
         ps.setString(3, user.getPassword());
         return ps;
      }
   }
   
   StatementStrategy st = new AddStatement();
   jdbcContextWithStatementStrategy(st);
}
}}}

이를 통해 클래스 파일을 하나 줄일 수 있고, 로컬변수를 바로 가져다 쓸수 있게 되었다.

*익명 내부 클래스(anonymous inner class)*

방금 작성된 클래스는 add 메소드에서만 사용할 용도로 만들어 졌다. 그러므로 익명 내부 클래스를 이용해서 클래스 이름도 제거해보도록 한다.


익명 내부 클래스를 사용하는 방법은 다음과 같다.

new 인터페이스이름() { 클래스 본문 };

{{{
public void add(final User user) throws SQLException {
   jdbcContextWithStatementStrategy(
      new StatementStrategy() {
         public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
            PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values (?, ?, ?)");
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getPassword());
            return ps;
         }
      }
   );
}

public void deleteAll() throw SQLException {
   jdbcContextWithStatementStrategy(
      new StatementStrategy() {
         public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
            return c.prepareStatement("delete from users");
         }
      }
   );
}
}}}

== 3.4 컨텍스트와 DI ==

jdbcContextWithStatementStrategy 메소드는 모든 DAO 에서 사용가능하다. 그러므로 독립적인 클래스로 분리시켜본다.

{{{
...
public class JdbcContext {
   private DataSource dataSource;
   public void setDataSource(DataSource dataSource) {
      this.dataSource = dataSource; // DataSource 에 의존하고 있으므로 DI 받게 해준다.
   }
   public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
      Connection c = null;
      PreparedStatement ps = null;
      try {
         c = this.dataSource.getConnection();
         ps = stmt.makePreparedStatement(c);
         ps.executeUpdate();
      } catch (SQLException e) {
         ...
      } finally {
         ...
      }
   }
}
}}}

{{{
public class UserDao {
   ...
   private JdbcContext jdbcContext;
   public void setJdbcContext(jdbcContext) {
      this.jdbcContext = jdbcContext;
   }

   public void add(final User user) throws SQLException {
      this.jdbcContext.workWithStatementStrategy(
         new StatementStrategy() {...};
      );
   }

   public void deleteAll() throws SQLException {
      this.jdbcContext.workWithStatementStrategy(
         new StatementStrategy() {...};
      );
   }
}
}}}

UserDao 는 JdbcContext 에 의존하고 있으므로 DI 받을 수 있도록 한다.

*빈 의존관계 변경*

바뀐 코드를 따라서 ApplicationContext 설정도 바뀌어야 한다.

{{{
<beans>
   <bean id="userDao" class="springbook...UserDao">
      <property name="jdbcContext" ref="jdbcContext" />
   </bean>

   <bean id="jdbcContext" class="springbook...JdbcContext">
      <property name="dataSource" ref="dataSource" />
   </bean>

   <bean id="dataSource" class="org....SimpleDriverDataSource">
      ...
   </bean>
</beans>
}}}

스프링의 DI 는 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는게 목적이지만 jdbcContext 는 그렇지 못하고 있다. 하지만 굳이 인터페이스를 통해서 사용하게 하지 않아도 된다.

첫번째 이유로 jdbcContext 가 스프링의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문이다. jdbcContext 의 경우 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 일종의 서비스 오브젝트로서 의미가 있다. 

두번째 이유로 DI 를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두다 스프링의 빈으로 등록되어야 하는데, jdbcContext 가 DI 를 통해 다른 빈에 의존하고 있기 때문이다.


강력한 결합을 가진 관계를 허용하면서도 싱글톤으로 만들고, DI 필요성을 위해 스프링의 빈으로 등록해서 UserDao 에 DI 되도록 만들어져도 좋은 것이다.


== 3.5 템플릿과 콜백 ==



== 3.6 스프링의 JdbcTemplate ==


= 생각하기 =