#summary 토비의 스프링, 1부 이해 - 1장 오브젝트와 의존관계

<wiki:toc max_depth="2" />

= 내용정리 =

== 1.1 초난감 DAO ==

제목은 초난감DAO 이지만 많이 보고 익숙한 코드였다. 


== 1.2 DAO의 분리 ==

*관심사의 분리 Separation of Concerns*
: 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

중복된 코드가 존재하는 UserDao 에 있는 2개의 메소드에서 중복 코드를 새로운 메소드로 추출해 보지만 (alt+shift+m이 떠오른다ㅋ)

{{{
public void add(User user) throws ClassNotFoundException, SQLException {
   Connection c = getConnection();
   ....
}

public void get(String id) throws ClassNotFoundException, SQLException {
   Connection c = getConnection();
   ....
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
   ...
   return DriverManager.getConnection(....);
}
}}}

여전히 UserDao 에서 디비 접근 방법에 대한 정보를 가지고 있음이 문제가 되었다.

그래서 UserDao 를 추상클래스, 추상메소드로 변경하고 이를 상속한 각각의 Dao 가 getConnection 메소드를 오버라이딩 할 수 있게 하였다. 이 과정에서 두 가지 디자인 패턴이 사용되었다.

*[http://underclub.tistory.com/124 템플릿 메소드 패턴]* : 
하위 클래스에서 어떤 구현을 하더라도 상위 클래스에서는 정해진대로 큰 흐름만을 처리한다.
*[http://underclub.tistory.com/125 팩토리 메소드 패턴]* : 
상위 클래스에서 훅 메소드 혹은 추상 메소드를 오버라이딩하여 구현하며 슈퍼클래스의 기본 코드에서 독립시킨다.

{{{
public abstract class UserDao {
    public void add(...) { .......... }
    public void get(...) { .......... }
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
   public Connection getConnection() throw ClassNotFoundException, SQLException {
      // n사 connection 생성코드
   }
}

public class DUserDao extends UserDao {
   public Connection getConnection() throw ClassNotFoundException, SQLException {
      // d사 connection 생성코드
   }
}
}}}


하지만 상하위 클래스의 밀접한 관계를 가지는 상속의 단점을 그대로 안고 있는 UserDao 는 다시 리팩토링 되어야 할 것이다. 다중상속이 되지 않아 확장이 어려우며, 밀접한 연결 관계는 변화에 대해 개방적이다.


== 1.3 DAO의 확장 ==



== 1.4 제어의 역전 ==


== 1.5 스프링의 IoC ==


== 1.6 싱글톤 레지스트리와 오브젝트 스코프 ==


== 1.7 의존관계 주입(DI) ==


== 1.8 XML을 이용한 설정 ==

애노테이션으로 설정된 application context 클래스를 XML 로 변경해본다.
ref 속성으로 여전히 의존관계를 설정할 수 있다.
(d사와 n사는 각자 가져가서 알아서 쓸테지만 ref 를 잘 설명할 수 있을 것 같아 예제를 좀 바꾸어 보았다.)

*applicationContext.xml*
{{{
<beans>
  <bean id="dConnectionMaker" class="springbook...DConnectionMaker" />
  <bean id="nConnectionMaker" class="springbook...NConnectionMaker" />

  <bean id="userDao" class="springbook...UserDao">
     <property name="connectionMaker" ref="dConnectionMaker" />
  </bean>
</beans>
}}}

xml을 이용해 application context 를 만들었으니 생성자도 같이 바뀐다.

{{{
ApplicationContext context = new GenericXmlApplicionContext("applicationContext.xml");
}}}

*DataSource 구현 클래스 이용하기*

(결국 이 길고 긴 설명을 통해 dataSource DI 까지 겨우 왔다.
당연히 가져다 쓰면 되겠지~ 했던 이 dataSource 까지도 아 네가 이 과정을 거쳐왔구나 하고 깊게 생각하게 된다ㅋ)

{{{
<bean id="dataSource" class="org.springframewokr.jdbc.datasource.SimpleDriverDataSource">
   <property name="driverClass" value="com.mysql.jdbc.Driver" />
   <property name="url" value="jdbc:mysql://localhost/springbook" />
   <property name="username" value="spring" />
   <property name="password" value="book" />
</bean>

<bean id="userDao" class="springbook...UserDao">
   <bean id="dataSource" ref="dateSource" />
</bean>
}}}


나는 처음 개발할 때 applicationContext 를 xml 로만 작성해서인지
애노테이션에 적응이 덜 되서 인지
한 눈에 파악할 수 있는 XML 방식이 더 편하고 좋은 것 같다.
여러분의 생각은 어떠신지요??


= 생각하기=

"여기 xml 에서 정의하시고 블라블라블라~ 그리고 setter 없으면 에러나요!"
"스트러츠했었다고요? 그럼 금방하겠네~ 비슷해요~"
약 1년전, 스트러츠만 하다가 스프링프로젝트에 처음 들어왔을 때
동료가 설명해준 스프링에 대한 나의 기억이다. 

이 기억들은 스프링교육이나 책을 공부하면서 점점 의미를 더해가고 있다.
그렇다고 왜 에러가 나는지 몰랐다는 뜻은 아니다. 다만 IoC, DI 라는 개념을 생각해 봤을 때
나는 그저 "그냥 그래야만해~" 라고 깊게 생각하지 않고 개발을 해왔던 것 같다.